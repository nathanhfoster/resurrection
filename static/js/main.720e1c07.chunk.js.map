{"version":3,"sources":["../../src/utils/actionTypes.js","../../src/utils/bindActionCreators.js","../../src/utils/isFunction.js","../../src/utils/defaultInitializer.js","../../src/utils/getDerivedStateFromProps.js","../../src/utils/getRandomInt.js","../../src/utils/defaultReducer.js","../../src/utils/shallowEquals.js","../../src/hooks/useLazyMemo.js","../../src/hooks/useReducerWithThunk.js","../../src/provider.js","../../src/utils/combineReducers.js","../../src/connect.js","../../src/hooks/usePreviousValue.js","SomeProviderChild.js","App.js","index.js"],"names":["randomString","Math","BindActionCreators","mapDispatchToProps","dispatch","Error","Object","key","action","acc","args","actionCreator","bindActionCreator","isFunction","object","stateOrProps","min","max","getDerivedStateFromProps","state","props","defaultReducer","prevState","shallowEquals","a","b","aKeys","i","bKeys","useLazyMemo","initializer","ref","useRef","observer","newObserver","getObservable","setStateHookReducer","store","isReady","getState","StateProvider","createContext","ContextStore","name","Context","context","reducers","initialState","children","getInitialMainState","useCallback","globalReducerFunction","hasStateChanged","updatedStateByReducers","reducerKey","currentStateByKey","returnedStateByReducer","currentReducer","combinedStateAndReducers","reducer","undefined","type","combineReducers","mainState","defaultInitializer","getInitialHookState","initialHookState","useReducer","hookState","setHookState","setState","nextState","newState","reduce","useEffect","useReducerWithThunk","useLayoutEffect","contextStore","useMemo","warnedAboutMissingDevToolRef","window","value","React","mapStateToProps","mergeProps","options","usePreviousValue","prevValue","connect","someKeyFromMyStore","pure","areStatePropsEqual","areMergedPropsEqual","MemoizedComponent","memo","Component","useContext","stateToProps","dispatchToProps","bindActionCreators","prevMergeProps","handleMergeProps","getMergedProps","merge","stateProps","dispatchProps","nextMergedProps","mergedProps","ownProps","DEFAULT_STATE","someReducer","payload","SomeProvider","ReactDOM","render","App","document","getElementById"],"mappings":"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","file":"static/js/main.720e1c07.chunk.js","sourcesContent":["/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nconst randomString = () =>\n  Math.random().toString(36).substring(7).split('').join('.')\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${randomString()}`,\n  REPLACE: `@@redux/REPLACE${randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n}\n\nexport default ActionTypes\n","/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Thunk} dispatch - the dispatch function available from the useReducerWithThunk hook\n\n * @returns {Action|ThunkActionDispatch} - An actionCreator object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @returns {Action} - the action callback function\n *\n * @returns {ThunkActionDispatch} - The object mimicking\n * the original object, but with\n * every action creator wrapped into the dispatch call. If you passed a\n * function as actionCreators, the return value will also be a single\n * function.\n */\nconst bindActionCreator = (dispatch) => (actionCreator) => (...args) =>\n  dispatch(actionCreator?.apply?.(this, args) || actionCreator)\n\n/**\n * This augments actions to dispatch other actions and passes (dispatch, getState)\n * @param {Object} mapDispatchToProps - actions to be passed as props\n * @param {Thunk} dispatch - reducer dispatch API\n * @returns {Object.<String, Thunk>} object of augmented actions\n * */\n\nconst BindActionCreators = (mapDispatchToProps, dispatch) => {\n  if (typeof mapDispatchToProps !== 'object' || mapDispatchToProps === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        mapDispatchToProps === null ? 'null' : typeof mapDispatchToProps\n      }.`\n    )\n  }\n  const boundActionCreators = Object.entries(mapDispatchToProps).reduce(\n    (acc, [key, action]) => {\n      acc[key] = bindActionCreator(dispatch)(action)\n      return acc\n    },\n    {}\n  )\n\n  return boundActionCreators\n}\n\nexport default BindActionCreators\n","/**\n * This evaluates wheter an object is a function or not\n * @param {*} object - any object\n * @returns {Boolean} - if the obejct is a boolean\n * */\n\nconst isFunction = (object) =>\n  object instanceof Function || typeof object === 'function'\n\nexport default isFunction\n","/**\n * @param {ReducerState|ComponentProps} stateOrProps - reducer state\n * @returns {ReducerState} - reducer state\n */\n\nexport default (stateOrProps) => stateOrProps\n","/**\n * This function allows the state to be controlled by an HOC by overwritting it with props\n * @param {ReducerState} state - state object\n * @param {ComponentProps|Object=} props - props to make the state controlled from an HOC\n * @returns {ReducerState} - the new merged state\n */\n\nconst getDerivedStateFromProps = (state, props) => ({\n  ...(state && {\n    ...state\n  }),\n  ...(props && {\n    ...props\n  })\n})\n\nexport default getDerivedStateFromProps\n","/**\n * This functions returns a random integer within a specified range\n * @param {Number} min - the lower limit of the integer\n * @param {Number} max - the upper limit of the integer\n * @returns {Number} - random integer\n */\n\nconst getRandomInt = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1)) + min\n\nexport default getRandomInt\n","import getDerivedStateFromProps from './getDerivedStateFromProps'\n/**\n * Mimics React.Component this.setState\n * @param {ReducerState} state - current reducer state\n * @param {ReducerState} action - the state keys to overwrite\n * @returns {ReducerState} - the next state for the reducer\n */\nconst defaultReducer = (prevState, action) =>\n  getDerivedStateFromProps(prevState, action)\n\nexport default defaultReducer\n","/**\n * This function does a shallow comparison on two objects\n * @param {Object} a - first object to compare\n * @param {Object} b - second object to compare\n * @returns {Boolean} - whether the two objects are equal or not\n * */\n\nconst shallowEquals = (a, b) => {\n  if (a === b) return true\n  if (!(a || b)) return true\n\n  const aKeys = Object.keys(a)\n  for (let i = 0; i < aKeys.length; i++) {\n    const key = aKeys[i]\n    if (!(key in b) || a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  const bKeys = Object.keys(b)\n  for (let i = 0; i < bKeys.length; i++) {\n    const key = bKeys[i]\n    if (!(key in a) || a[key] !== b[key]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport default shallowEquals\n","import { useRef } from 'react'\n\nconst DEFAULT_VALUE = null\n\n/**\n * This function is used to overcome this potential issue of the useMemo:\n * You may rely on useMemo as a performance optimization, not as a semantic guarantee.\n * In the future, React may choose to “forget” some previously memoized values\n * and recalculate them on next render, e.g. to free memory for offscreen components.\n * Write your code so that it still works without useMemo — and then add it to optimize performance.\n * (For rare cases when a value must never be recomputed, you can lazily initialize a ref.)\n * {@link https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily ReactDocs}\n * @param {function(): *} initializer - the callback function that will only be ran once\n * @returns {*} - a lazily loaded value\n * */\nexport const useLazyMemo = (initializer) => {\n  const ref = useRef(DEFAULT_VALUE)\n\n  const getObservable = () => {\n    const observer = ref.current\n    if (observer !== DEFAULT_VALUE) {\n      return observer\n    }\n\n    const newObserver = initializer()\n    ref.current = newObserver\n    return newObserver\n  }\n\n  return getObservable()\n}\n\nexport default useLazyMemo\n","import { useReducer, useRef, useCallback, useEffect } from 'react'\nimport {\n  isFunction,\n  getDerivedStateFromProps,\n  defaultReducer,\n  defaultInitializer\n} from '../utils'\nimport useLazyMemo from './useLazyMemo'\n\n/**\n * Mimics React.Component this.setState\n * @param {ReducerState} prevState - the reducer's previous state\n * @param {ReducerState} nextState - the state to overwrite\n * @returns {ReducerState} - the next state for the reducer\n */\nconst setStateHookReducer = defaultReducer\n\n/**\n * Augments React's useReducer() hook so that the action dispatcher supports thunks.\n * @param {Reducer} reducer - reducer\n * @param {ReducerState=} initialState - initialState\n * @param {ReducerStateInitializer=} initializer - initilizes the reducer's state\n * @param {ComponentProps=} props - props to make the state controlled from a HOC\n * @returns {Array.<ReducerState, Thunk>} - the new useReducer hook\n */\nconst useReducerWithThunk = (\n  reducer,\n  initialState,\n  initializer = defaultInitializer,\n  props\n) => {\n  // Get initial hook state once\n  const getInitialHookState = useCallback(\n    () => getDerivedStateFromProps(initialState, props),\n    []\n  )\n  const initialHookState = useLazyMemo(getInitialHookState)\n\n  const [hookState, setHookState] = useReducer(\n    setStateHookReducer,\n    initialHookState,\n    initializer\n  )\n\n  // State management\n  const state = useRef(hookState)\n\n  const getState = useCallback(() => state.current, [state])\n\n  const setState = useCallback(\n    (newState) => {\n      const nextState = getDerivedStateFromProps(newState, props)\n      state.current = nextState\n      setHookState(nextState)\n    },\n    [props, setHookState]\n  )\n\n  // Reducer\n  const reduce = useCallback((action) => reducer(getState(), action), [\n    reducer,\n    getState\n  ])\n\n  /** Augmented dispatcher\n   * @param {Action|ThunkActionDispatch} action - action\n   * @returns {Thunk} - the new dispatch API\n   */\n  const dispatch = useCallback(\n    (action) => {\n      if (isFunction(action)) {\n        return action(dispatch, getState)\n      }\n      return setState(reduce(action))\n    },\n    [getState, setState, reduce]\n  )\n\n  useEffect(() => {\n    if (state.current) {\n      state.current = getDerivedStateFromProps(state.current, props)\n      setHookState(props)\n    }\n  }, [props])\n\n  return [hookState, dispatch]\n}\n\nexport default useReducerWithThunk\n","import React, {\n  createContext,\n  useCallback,\n  useRef,\n  useLayoutEffect,\n  useMemo\n} from 'react'\nimport {\n  combineReducers,\n  shallowEquals,\n  defaultInitializer,\n  defaultReducer,\n  getRandomInt\n} from './utils'\nimport useLazyMemo from './hooks/useLazyMemo'\nimport useReducerWithThunk from './hooks/useReducerWithThunk'\nimport './types'\n\nconst inDevelopmentMode = process.env.NODE_ENV === 'development'\n\nconst storeFactory = () => ({\n  isReady: false,\n  dispatch: () => {\n    throw Error('Store is NOT ready!')\n  },\n  getState: () => {\n    throw Error('Store is NOT ready!')\n  }\n})\n// Use this only if you want to use a global reducer for your whole app\nconst store = storeFactory()\n\nconst StateProvider = createContext(null)\n\n/**\n * Context Store Factory that simulates Redux's createStore API\n * @param {ContexStoreProps} props - ContextStore props\n * @returns {React.ContextProvider} - a React Context with the store as it's value\n */\nconst ContextStore = ({\n  name,\n  context: Context,\n  reducers,\n  initialState,\n  props,\n  initializer,\n  children\n}) => {\n  // call the function once to get initial state and global reducer\n  const getInitialMainState = useCallback(\n    () => combineReducers(reducers, initialState),\n    []\n  )\n  const [mainState, mainReducer] = useLazyMemo(getInitialMainState)\n\n  // setup useReducer with the returned values of the combineReducers\n  const [state, dispatch] = useReducerWithThunk(\n    mainReducer,\n    mainState,\n    initializer,\n    props\n  )\n\n  // Update store object to potentially access it outside of a component\n  useLayoutEffect(() => {\n    if (!store.isReady) {\n      store.isReady = true\n      store.dispatch = dispatch\n      store.getState = () => state\n      // Object.freeze(store) // don't freeze the object, or store.isReady can't be re-assigned\n    }\n    return () => {\n      store.isReady = false\n    }\n  }, [state, dispatch])\n\n  // make the context object value\n  const contextStore = useMemo(\n    () => ({\n      state,\n      dispatch\n    }),\n    [state, dispatch]\n  )\n\n  const warnedAboutMissingDevToolRef = useRef(false)\n\n  useLayoutEffect(() => {\n    if (\n      typeof window !== 'undefined' &&\n      // eslint-disable-next-line\n      window._REACT_CONTEXT_DEVTOOL &&\n      inDevelopmentMode\n    ) {\n      // eslint-disable-next-line\n      window._REACT_CONTEXT_DEVTOOL({\n        id: name,\n        displayName: name,\n        values: contextStore\n      })\n    } else if (!warnedAboutMissingDevToolRef.current && inDevelopmentMode) {\n      warnedAboutMissingDevToolRef.current = true\n      // eslint-disable-next-line\n      console.info(\n        '%cConsider installing \"React Context DevTool\" in order to inspect the Wisteria state',\n        'color:#1dbf73'\n      )\n    }\n  }, [contextStore])\n\n  return <Context.Provider value={contextStore}>{children}</Context.Provider>\n}\n\nContextStore.defaultProps = {\n  name: getRandomInt(0, 1000),\n  context: StateProvider,\n  reducers: defaultReducer,\n  initializer: defaultInitializer,\n  initialState: undefined,\n  props: undefined\n}\n\nconst MemoizedContextProvider = React.memo(ContextStore, shallowEquals)\n\nexport {\n  StateProvider as ContextConsumer,\n  ContextStore as ContextProvider,\n  MemoizedContextProvider,\n  store\n}\n","import isFunction from './isFunction'\n/**\n * This function returns one reducer if it is a Function\n * otherwise, it combines an object of reducer functions\n * @param {Reducer|Object.<string, Reducer>} reducers - reducer(s) to combine\n * @param {ReducerState} initialState - the initial state of the reducer\n * @returns {Array.<ReducerState, Reducer|CombinedReducers>} - an array of\n * [globalState, globalReducer]\n * */\nconst combineReducers = (reducers, initialState) => {\n  // If a single reducer return\n  if (isFunction(reducers)) {\n    return [initialState || {}, reducers]\n  }\n\n  /**\n   * Global reducer function; this is passed to the useReducer hook\n   * @param {ReducerState} state - reducer state\n   * @param {ReducerAction} action - action\n   * @returns {Array.<ReducerState, Reducer|CombinedReducers>} - combined reducers\n   */\n  const globalReducerFunction = (state, action) => {\n    let hasStateChanged = false\n    const updatedStateByReducers = {}\n\n    /**\n     * this is where dispatching happens;\n     * the action is passed to all reducers one by one.\n     * we iterate and pass the action to each reducer and this would return new\n     * state if applicable.\n     */\n    for (let i = 0; i < reducers.length; i++) {\n      const reducerKey = reducers[i]\n      if (Object.prototype.hasOwnProperty.call(reducers, reducerKey)) {\n        const currentStateByKey = state[reducerKey]\n        const currentReducer = reducers[reducerKey]\n\n        const returnedStateByReducer = currentReducer(currentStateByKey, action)\n\n        const areStateByKeyEqual = returnedStateByReducer !== currentStateByKey\n\n        hasStateChanged = hasStateChanged || areStateByKeyEqual\n\n        updatedStateByReducers[reducerKey] = returnedStateByReducer\n      }\n    }\n    return hasStateChanged ? updatedStateByReducers : state\n  }\n  let combinedStateAndReducers\n\n  if (initialState) {\n    combinedStateAndReducers = [initialState, globalReducerFunction]\n  } else {\n    // set default state returned by reducer and its reducer\n    const globalState = Object.entries(reducers).reduce(\n      (acc, [key, reducer]) => {\n        if (isFunction(reducer)) {\n          acc[key] = reducer(undefined, {\n            type: '__@@PLACEHOLDER_ACTION__'\n          })\n        } else {\n          throw new Error(`${reducer} is not a function`)\n        }\n        return acc\n      },\n      {}\n    )\n    combinedStateAndReducers = [globalState, globalReducerFunction]\n  }\n\n  return combinedStateAndReducers\n}\n\nexport default combineReducers\n","import React, { memo, useCallback, useContext, useMemo } from 'react'\nimport { isFunction, bindActionCreators, shallowEquals } from './utils'\nimport { usePreviousValue } from './hooks'\nimport { ContextConsumer } from './provider'\nimport './types'\n\n/**\n * This function simulates Redux's connect API\n * @param {MapStateToProps} mapStateToProps - reducer dispatch API\n * @param {MapDispatchToProps} mapDispatchToProps - reducer state\n * @param {Function=} mergeProps - function to merge props\n * @param {ConnectOptions=} options - options\n * @returns {React.memo|React.FunctionComponent} - a connected component\n * */\n\nconst connect = (mapStateToProps, mapDispatchToProps, mergeProps, options) => (\n  Component\n) => {\n  const {\n    context = ContextConsumer,\n    pure = true,\n    // TODO:\n    // areStatesEqual = shallowEquals,\n    // areOwnPropsEqual = shallowEquals,\n    areStatePropsEqual = shallowEquals,\n    areMergedPropsEqual = shallowEquals\n    // forwardRef = false,\n  } = options || {}\n  // Conditionally memoize Component\n  const MemoizedComponent =\n    pure === true ? memo(Component, areStatePropsEqual) : Component\n  return (ownProps) => {\n    const { state, dispatch } = useContext(context)\n\n    const stateToProps = useMemo(() => {\n      if (isFunction(mapStateToProps)) {\n        return mapStateToProps(state, ownProps)\n      }\n      return {}\n    }, [state, ownProps])\n\n    const dispatchToProps = useMemo(() => {\n      if (!mapDispatchToProps) {\n        return {}\n      }\n      if (isFunction(mapDispatchToProps)) {\n        return mapDispatchToProps(dispatch)\n      }\n      return bindActionCreators(mapDispatchToProps, dispatch)\n    }, [dispatch])\n\n    const prevMergeProps = usePreviousValue(mergeProps)\n\n    const handleMergeProps = useCallback(\n      (stateProps, dispatchProps, props) => {\n        const getMergedProps = (merge) =>\n          isFunction(merge)\n            ? merge(stateProps, dispatchProps, props)\n            : { ...props, ...stateProps, ...dispatchProps }\n\n        const nextMergedProps = getMergedProps(mergeProps)\n\n        if (\n          !pure ||\n          (prevMergeProps &&\n            !areMergedPropsEqual(nextMergedProps, prevMergeProps))\n        ) {\n          return nextMergedProps\n        }\n\n        return getMergedProps(prevMergeProps)\n      },\n      [prevMergeProps]\n    )\n\n    const mergedProps = useMemo(\n      () => handleMergeProps(stateToProps, dispatchToProps, ownProps),\n      [ownProps, handleMergeProps, stateToProps, dispatchToProps]\n    )\n\n    return <MemoizedComponent {...mergedProps} dispatch={dispatch} />\n  }\n}\n\nexport default connect\n","import { useEffect, useRef } from 'react'\n\n/**\n * On each render returns the previous value of the given variable/constant\n * @param {*} value - any value\n * @returns {*} any previous value\n */\nconst usePreviousValue = (value) => {\n  const prevValue = useRef(value)\n\n  useEffect(() => {\n    prevValue.current = value\n\n    return () => {\n      prevValue.current = undefined\n    }\n  })\n\n  return prevValue.current\n}\n\nexport default usePreviousValue\n","import React from 'react'\nimport { connect } from 'resurrection'\n\nconst SomeProviderChild = ({ someKeyFromMyStore }) => (\n  <div>{someKeyFromMyStore}</div>\n)\n\nconst mapStateToProps = ({ someKeyFromMyStore }) => ({ someKeyFromMyStore })\n\nexport default connect(mapStateToProps)(SomeProviderChild)\n","import React from 'react'\nimport { ContextProvider } from 'resurrection'\nimport SomeProviderChild from './SomeProviderChild'\n\nconst DEFAULT_STATE = {\n  someKeyFromMyStore: 'Hello World'\n}\n\nconst someReducer = (state = DEFAULT_STATE, action) => {\n  const { type, payload } = action\n\n  switch (type) {\n    case 'SOME_ACTION_TYPE':\n      return { ...state, someKeyFromMyStore: payload }\n\n    default:\n      return state\n  }\n}\n\nconst SomeProvider = () => (\n  /* reducers can be a single reducer function or an object of reducers */\n  /* object of reducers example: const reducers = { someReducer, someOtherReducer} */\n  <ContextProvider reducers={someReducer}>\n    <SomeProviderChild />\n  </ContextProvider>\n)\n\nexport default SomeProvider\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}